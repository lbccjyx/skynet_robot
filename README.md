这是一个开发进度0.1%的游戏, 玩家可以注册登录。

然后当我们在页面输入1 + 语句 可以得到原本的string 当我们在页面输入 2+num 可以在这个玩家上创建 num个机器人。

现在自然是没什么用了。机器人就算是NPC把。比如我们有一座城池，里面的每个NPC都可以有自己的事情-现在的事情就是输出文字。然后我们是城主。城主的逻辑还没写。NPC的逻辑也还没写。


先下载 https://github.com/cloudwu/skynet.git 然后进入skynet 这里我叫他 工作目录 
然后下载本项目skynet_robot 

然后重命名 skynet_rebot 改名为 robot 放入 工作目录。 

工作目录下 命令: make 'linux' 
工作目录下 命令: ./skynet robot/config 

对了这样肯定是跑不起来的。还需要在linux上部署mysql-service 然后按照 robot/config 上面的配置去创建数据库。 表结构也还没写。
然后最后还要把client整个文件下载下来，然后打开那个html。


比较有趣的点：
同账号玩家登录 另一边马上给他踢出。
玩家设置的机器人个数在下次登录的时候也全都还在。
玩家带有socket_id 还有 agent的服务句柄 所以拿到玩家类基本上就可以和客户端通讯。
数据库、websocket、server 核心功能放在core目录下 每个模块职责单一 错误处理更加统一、代码重复度降低


全局变量模式的优劣：（用户管理、机器人管理这种核心服务）
优势：
完全符合Skynet的设计理念，每个服务都是独立的actor
服务间通过消息传递通信，不会有并发访问的问题
服务地址（handle）全局唯一，便于跨服务调用
服务崩溃后可以重启，不会影响其他服务
适合分布式部署，服务可以在不同节点上运行
劣势：
需要通过环境变量或其他方式保存服务地址
服务间通信需要通过skynet.call/send，有一定的开销
代码组织相对松散，需要显式管理服务生命周期

单例模式的优劣：（数据库连接这种工具类功能）
优势：
代码组织更紧凑，面向对象风格更明显
访问更方便，不需要通过消息传递
初始化逻辑集中，易于管理
内存占用可能更少（没有服务调度开销）
劣势：
在Skynet的多服务环境中可能产生并发问题
如果多个服务同时访问单例，需要额外的同步机制
单例状态在服务重启时会丢失
不适合分布式部署
一旦单例出问题，可能所有玩家都会受影响











